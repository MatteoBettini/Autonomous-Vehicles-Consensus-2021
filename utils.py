import csv
from pathlib import Path
import sys
import os
from lxml import etree
from xml.etree import ElementTree
import numpy as np


def get_project_root() -> Path:
    return Path(__file__).resolve().parent.absolute()

def checkSumoHome():
    if 'SUMO_HOME' in os.environ:
        sys.path.append(os.path.join(os.environ['SUMO_HOME'], 'tools'))
    else:
        print("SUMO_HOME must be declared")
        sys.exit(1)


class DefaultParams:

    # SIM PARAMS
    RING_RADIUS = 41.4
    MAX_SPEED = 30
    TARGET_SPEED = MAX_SPEED
    MAX_ACCEL = 2
    MAX_DECEL = MAX_ACCEL
    N_VEHICLES = 20
    N_BROKEN_VEHICLES = 0
    DURATION = 300
    INITIAL_HEADWAY = ((2 * np.pi * RING_RADIUS) / N_VEHICLES) - 5  # Vehicle length
    SIM_STEP = 0.1
    TAU = SIM_STEP + 0.03

    # PID HEADWAY PARAMS
    TARGET_HEADWAY = 0.6 * TARGET_SPEED + 2

    # INIT PARAMS
    BUNCHING = 0
    PERTURBATION = 0

    # CONSENSUS PARMS
    V_INC = 0.2
    N_HOPS = -1


    FAIL_SAFES = ["obey_speed_limit", "feasible_accel"]



class PathUtils:

    # FOLDERS

    data_folder = get_project_root() / 'data'
    exp_configs_folder = get_project_root() / 'exp_configs'
    ring_configs_folder = exp_configs_folder / 'ring'


    # FILES

    run_ring_file = get_project_root() / 'run_ring.py'
    ring_json_file = data_folder / 'ring.json'




def emission_to_csv(emission_path: str, output_path=None):
    """Convert an emission file generated by sumo into a csv file.

    Note that the emission file contains information generated by sumo, not
    flow. This means that some data, such as absolute position, is not
    immediately available from the emission file, but can be recreated.

    Parameters
    ----------
    emission_path : str
        path to the emission file that should be converted
    output_path : str
        path to the csv file that will be generated, default is the same
        directory as the emission file, with the same name
    """
    parser = etree.XMLParser(recover=True)
    tree = ElementTree.parse(emission_path, parser=parser)
    root = tree.getroot()

    # parse the xml data into a dict
    out_data = []
    for time in root.findall('timestep'):
        t = float(time.attrib['time'])

        for car in time:
            out_data.append(dict())
            try:
                out_data[-1]['time'] = t
                out_data[-1]['CO'] = float(car.attrib['CO'])
                out_data[-1]['y'] = float(car.attrib['y'])
                out_data[-1]['CO2'] = float(car.attrib['CO2'])
                out_data[-1]['electricity'] = float(car.attrib['electricity'])
                out_data[-1]['type'] = car.attrib['type']
                out_data[-1]['id'] = car.attrib['id']
                out_data[-1]['eclass'] = car.attrib['eclass']
                out_data[-1]['waiting'] = float(car.attrib['waiting'])
                out_data[-1]['NOx'] = float(car.attrib['NOx'])
                out_data[-1]['fuel'] = float(car.attrib['fuel'])
                out_data[-1]['HC'] = float(car.attrib['HC'])
                out_data[-1]['x'] = float(car.attrib['x'])
                out_data[-1]['route'] = car.attrib['route']
                out_data[-1]['relative_position'] = float(car.attrib['pos'])
                out_data[-1]['noise'] = float(car.attrib['noise'])
                out_data[-1]['angle'] = float(car.attrib['angle'])
                out_data[-1]['PMx'] = float(car.attrib['PMx'])
                out_data[-1]['speed'] = float(car.attrib['speed'])
                out_data[-1]['edge_id'] = car.attrib['lane'].rpartition('_')[0]
                out_data[-1]['lane_number'] = car.attrib['lane'].\
                    rpartition('_')[-1]
            except KeyError:
                del out_data[-1]

    # sort the elements of the dictionary by the vehicle id
    out_data = sorted(out_data, key=lambda k: k['id'])

    # default output path
    if output_path is None:
        output_path = emission_path[:-3] + 'csv'

    # output the dict data into a csv file
    keys = out_data[0].keys()
    with open(output_path, 'w') as output_file:
        dict_writer = csv.DictWriter(output_file, keys)
        dict_writer.writeheader()
        dict_writer.writerows(out_data)


